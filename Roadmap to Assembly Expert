# THE ULTIMATE ASSEMBLY MASTERY & CYBERSECURITY ROADMAP
# Schedule: 6-8 Hours Per Day | Duration: 6+ Months

## DAILY DISCIPLINE (The 8-Hour Rule)
- 09:00 - 11:00: Theory & Architecture (Intel Manuals / Computer Systems: A Programmer's Perspective)
- 11:00 - 14:00: Active Coding (Writing .asm files and linking)
- 14:00 - 15:00: Break
- 15:00 - 17:00: Step-through Debugging (GDB/EDB - Inspecting Registers & Stack)
- 17:00 - 18:00: Reverse Engineering (Disassembling C binaries to see the ASM equivalent)

---

## PHASE 1: REGISTERS & THE CPU PIPELINE (Month 1)
Goal: Understand how data moves between General Purpose Registers (GPRs) and the CPU.



### Project 1.1: The "Pure" Hello World
- Features: Print text to the console without using C's printf.
- Requirements: Use syscall (sys_write) and sys_exit. Understand the syscall table.
- Goal: Mastery of the mov instruction and syscall registers (RAX, RDI, RSI, RDX).

### Project 1.2: Bitwise Logic & Arithmetic Engine
- Features: A program that takes two numbers and performs AND, OR, XOR, SHL, and SHR.
- Requirements: Use rax, rbx, and flags register.
- Goal: Understand the RFLAGS register (Zero Flag, Carry Flag).
- Security Value: Understanding how encryption algorithms (like AES) manipulate bits at the register level.

### Project 1.3: Hexadecimal to ASCII Converter
- Features: Take a raw hex byte and convert it to a printable ASCII string.
- Requirements: Manual division (div) or bit-masking to isolate nibbles.
- Goal: Learning the difference between data representation and visual characters.

### üèÜ FINAL PROJECT: A Custom printf Implementation
- Features: Write a function in ASM that handles %s, %d, and %x.
- Requirements: Manual string scanning and integer-to-string conversion (itoa).
- Goal: Understanding the Calling Convention (System V AMD64 ABI).

---

## PHASE 2: THE STACK & FLOW CONTROL (Month 2)
Goal: Master branching (JMPs) and the Stack (rsp, rbp).



### Project 2.1: Recursive Factorial/Fibonacci
- Features: Calculate numbers using recursion.
- Requirements: Use push, pop, call, and ret.
- Goal: Master stack frame management (Procedures).
- Security Value: Understanding how a "Stack Overflow" occurs when recursion is infinite.

### Project 2.2: String Manipulation Suite
- Features: Re-implement strlen, strcmp, and strrev in ASM.
- Requirements: Use string instructions (lodsb, scasb, repne).
- Goal: Mastering loops and conditional jumps (jz, jnz, cmov).

### Project 2.3: Password Validator
- Features: Take user input via sys_read and compare it to a hardcoded "secret."
- Requirements: Buffer allocation in the .bss section.
- Goal: Understanding how memory offsets work in Assembly.

### üèÜ FINAL PROJECT: A Basic Command-Line Logic Game
- Features: A "Guess the Number" game with user input and logic loops.
- Requirements: Use rdrand (hardware random number generator) or a simple LCG.
- Goal: Combining flow control, stack management, and I/O.

---

## PHASE 3: INTERFACING & SYSTEMS (Months 3-4)
Goal: Mixed-language programming and interacting with the OS kernel.

### Project 3.1: The C-ASM Hybrid
- Features: Call an Assembly function from a C program and vice-versa.
- Requirements: Linking .o files with gcc.
- Goal: Understand how high-level languages "wrap" Assembly.
- Security Value: Many "obfuscated" programs hide malicious logic in ASM modules linked to C.

### Project 3.2: File IO & Encryptor
- Features: Open a file, read its contents, XOR the data, and write it back.
- Requirements: sys_open, sys_read, sys_write.
- Goal: Mastery of file descriptors and buffers in ASM.

### Project 3.3: Socket Connector
- Features: Open a TCP socket and send a message to a listener (Netcat).
- Requirements: Use syscall for sys_socket, sys_connect.
- Goal: Understanding network structures in memory.
- Security Value: The core of a "Reverse Shell" payload is written this way.

### üèÜ FINAL PROJECT: A Keylogger (Linux)
- Features: Capture keystrokes by reading /dev/input/.
- Requirements: Handling raw byte streams and file permissions.
- Goal: Low-level hardware event handling.

---

## PHASE 4: THE SHELLCODE & RE Tier (Months 5+)
Goal: Writing position-independent code (Shellcode) and Reverse Engineering.

### Project 4.1: Null-Free Execve Shellcode
- Features: Launch /bin/sh.
- Requirements: The code must contain NO null bytes (0x00).
- Goal: Use xor eax, eax and other tricks to keep the payload clean.
- Security Value: This is the payload used in real-world Buffer Overflow exploits.

### Project 4.2: The Polymorphic Engine
- Features: An ASM stub that "mutates" itself by XORing its own body.
- Requirements: Self-modifying code sections (requires mprotect).
- Goal: Understanding how malware evades signature-based detection.

### üèÜ FINAL PROJECT: The Linux Egg Hunter / Virus Stub
- Features: A small program that searches memory for a "tag" (The Egg) and executes the code found there.
- Requirements: Memory scanning and signal handling (to prevent crashes on bad addresses).
- Goal: Advanced exploit technique for when space is limited in a buffer.

---

## ESSENTIAL RESOURCES
1. Intel¬Æ 64 and IA-32 Architectures Software Developer‚Äôs Manuals (The ultimate truth).
2. Computer Systems: A Programmer's Perspective (CS:APP) - Best for understanding memory.
3. The Art of Assembly Language (Randall Hyde) - A softer introduction.
4. Modern x86 Assembly Language Programming (Daniel Kusswurm).

---

## üõ† REQUIRED TOOLKIT
- Assembler: nasm or yasm.
- Linker: ld.
- Debugger: gdb (highly recommend the Dashboard or GEF plugin to see registers).
- Static Analysis: objdump -d (Disassembler), strace (to see syscalls).
- The "Cheat Sheet": The x64 Syscall Table (online).
